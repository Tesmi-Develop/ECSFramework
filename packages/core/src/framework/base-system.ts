import { Modding, Reflect } from "@flamework/core";
import { Constructor } from "@flamework/core/out/utility";
import jecs, { Entity, Id } from "@rbxts/jecs";
import { ECSFramework } from ".";
import { DestroyComponent } from "./components/destroyed-component";
import { Calculate, ExtractQueryTypes, query, QueryHandle, ToIds } from "./flamecs";
import {
	add,
	added,
	changed,
	ChildOf,
	ComponentKey,
	ExtractPredicate,
	get,
	getId,
	getKey,
	has,
	insert,
	Pair,
	remove,
	removed,
	ResolveKey,
	ResolveKeys,
	ResolveValue,
	ResolveValues,
	set,
	Tag,
	target,
	Unwrap,
} from "./flamecs/registry";
import { Signal } from "./flamecs/signal";
import { InjectType } from "./decorators/inject-type";
import { QueryChange } from "./hooks/query-change";
import { produce } from "@rbxts/immut";
import { WritableDraft } from "@rbxts/immut/src/types-external";

type TrailingUndefined<T extends Array<unknown>> = T extends [...infer Rest, undefined]
	? [...TrailingUndefined<Rest>, undefined?]
	: T;

/** @metadata reflect identifier */
export abstract class BaseSystem {
	@InjectType
	protected readonly world!: jecs.World;
	@InjectType
	private framework!: ECSFramework;
	/** @hidden */
	public __hookStates = {};

	constructor() {}

	//#region Component
	/**
	 * Adds a pair relationship with a specific target entity.
	 *
	 * @template T - The type of the pair.
	 * @param entity - The entity to which the pair relationship is added.
	 * @param object - The target entity of the relationship (object of the pair).
	 * @param key - Flamework autogenerated key.
	 * @metadata macro
	 */
	public AddComponent<T extends Pair<Tag>>(
		entity: Entity,
		object: Entity,
		key?: ComponentKey<ExtractPredicate<T>>,
	): void;

	/**
	 * Adds a fully defined pair to an entity. This is used when both the predicate
	 * and object of the pair are known at compile-time.
	 *
	 * @template T - The type of the pair.
	 * @param entity - The entity to which the pair component is added.
	 * @param key - Flamework autogenerated key.
	 * @metadata macro
	 */
	public AddComponent<T extends Pair<Tag, defined>>(entity: Entity, key?: ResolveKey<T>): void;

	/**
	 * Adds a component to an entity.
	 *
	 * @template T - The type of the component.
	 * @param entity - The entity to which the component is added.
	 * @param key - Flamework autogenerated key.
	 * @metadata macro
	 */
	public AddComponent<T extends Tag>(entity: Entity, key?: ComponentKey<T>): void;

	public AddComponent(entity: Entity, argument1?: unknown, argument2?: unknown): void {
		return add(this.world, entity, argument1 as never, argument2 as never);
	}

	/**
	 * Sets a value for a pair with a specific runtime target entity.
	 *
	 * @template T - The type of the pair.
	 * @param entity - The entity to which the pair relationship is added.
	 * @param object - The target entity of the relationship (object of the pair).
	 * @param value - The value associated with the pair relationship.
	 * @param key - Flamework autogenerated key.
	 * @metadata macro
	 */
	public SetComponent<T extends Pair<defined>>(
		entity: Entity,
		object: Entity,
		value: ResolveValue<T>,
		key?: ComponentKey<ExtractPredicate<T>>,
	): void;

	/**
	 * Sets a value for a fully defined pair on an entity. This is used when both
	 * the predicate and object of the pair are known at compile-time.
	 *
	 * @template T - The type of the pair.
	 * @param entity - The entity to which the pair component is added.
	 * @param value - The value associated with the pair component.
	 * @param key - Flamework autogenerated key.
	 * @metadata macro
	 */
	public SetComponent<T extends Pair<defined, defined>>(
		entity: Entity,
		value: ResolveValue<T>,
		key?: ResolveKey<T>,
	): void;

	/**
	 * Sets a value for a component on an entity.
	 *
	 * @template T - The type of the component.
	 * @param entity - The entity to which the component is added or updated.
	 * @param value - The value associated with the component.
	 * @param key - Flamework autogenerated key.
	 * @metadata macro
	 */
	public SetComponent<T>(entity: Entity, value?: Unwrap<T>, key?: ComponentKey<T>): void;

	/**
	 * Sets a value for a component on an entity.
	 *
	 * @template T - The type of the component.
	 * @param entity - The entity to which the component is added or updated.
	 * @param value - The value associated with the component.
	 * @param key - Flamework autogenerated key.
	 * @metadata macro
	 */
	public SetComponent<T>(entity: Entity, value: Partial<T>, key?: ComponentKey<T>): void;

	public SetComponent(entity: Entity, argument1: unknown, argument2?: unknown, argument3?: unknown): void {
		const classComponent = this.GetClassComponent(argument2 as ComponentKey<unknown>);
		if (argument3 === undefined && classComponent !== undefined) {
			if (this.isTagComponent(classComponent)) {
				argument3 = undefined;
				return add(this.world, entity, argument2 as never, argument3 as never);
			}
			// Case class component
			const value = this.createComponentData(
				classComponent as unknown as { constructor: (data: unknown) => unknown },
				argument1 as Partial<unknown>,
			);

			return set(this.world, entity, value, argument2 as unknown as ComponentKey<unknown>);
		}

		return set(this.world, entity, argument1 as never, argument2 as never, argument3 as never);
	}

	/** @metadata macro */
	public MutateComponent<T>(
		entity: Entity,
		onMutate: (darft: WritableDraft<Unwrap<T>>, original: Unwrap<T>) => void,
		key?: ComponentKey<T>,
	): void {
		if (this.isTagComponent(this.GetClassComponent(key as ComponentKey<unknown>))) {
			throw `Tag components cannot be mutated.`;
		}

		const data = this.GetComponent(entity, key as ComponentKey<unknown>);
		if (!data) {
			throw `Component ${key} does not exist on entity ${entity}.`;
		}

		set<T>(
			this.world,
			entity,
			produce(data, (draft) => onMutate(draft as never, data as never)) as never,
			key as never,
		);
	}

	/**
	 * Adds or updates multiple components for the specified entity.
	 *
	 * @template T - The type of the components.
	 * @param entity - The entity to modify.
	 * @param keys - Flamework autogenerated keys.
	 * @metadata macro
	 */
	public InsertComponents<T extends Array<Tag>>(entity: Entity, keys?: ResolveKeys<T>): void;

	/**
	 * Adds or updates multiple components for the specified entity.
	 *
	 * @template T - The type of the components.
	 * @param entity - The entity to modify.
	 * @param values - The values to set for the components.
	 * @param keys - Flamework autogenerated keys.
	 * @metadata macro
	 */
	public InsertComponents<T extends Array<unknown>>(
		entity: Entity,
		values: TrailingUndefined<ResolveValues<T>>,
		keys?: ResolveKeys<T>,
	): void;

	public InsertComponents<T extends Array<unknown>>(entity: Entity, argument1?: unknown, argument2?: unknown): void {
		assert(argument1 !== undefined);

		if (argument2 !== undefined) {
			// Insert components: insert(entity, values, keys)
			const values = argument1 as TrailingUndefined<ResolveValues<T>>;
			const keys = argument2 as ResolveKeys<T>;

			const newValues = [] as unknown as TrailingUndefined<ResolveValues<T>>;

			for (let index = 0; index < keys.size(); index++) {
				const componentClass = this.GetClassComponent(keys[index]);
				const isTag = this.isTagComponent(componentClass);
				if (componentClass === undefined) {
					newValues[index] = values[index];
					continue;
				}

				if (componentClass !== undefined && isTag) {
					newValues[index] = undefined;
					continue;
				}

				const newData = this.createComponentData(
					componentClass as unknown as { constructor: (data: unknown) => unknown },
					values[index] as Partial<unknown>,
				);

				newValues[index] = newData;
			}

			return insert(this.world, entity, newValues, keys);
		}

		return insert(this.world, entity, argument1 as never, argument2 as never);
	}

	/**
	 * Removes a pair relationship with a specific target entity.
	 *
	 * @template T - The type of the pair.
	 * @param entity - The entity from which the pair relationship is removed.
	 * @param object - The target entity of the relationship (object of the pair).
	 * @param key - Flamework autogenerated key.
	 * @metadata macro
	 */
	public RemoveComponent<T extends Pair<defined>>(
		entity: Entity,
		object: Entity,
		key?: ComponentKey<ExtractPredicate<T>>,
	): void;

	/**
	 * Removes a fully defined pair from an entity. This is used when both the
	 * predicate and object of the pair are known at compile-time.
	 *
	 * @template T - The type of the pair.
	 * @param entity - The entity from which the pair component is removed.
	 * @param key - Flamework autogenerated key.
	 * @metadata macro
	 */
	public RemoveComponent<T extends Pair<defined, defined>>(entity: Entity, key?: ResolveKey<T>): void;

	/**
	 * Removes a component from an entity.
	 *
	 * @template T - The type of the component.
	 * @param entity - The entity from which the component is removed.
	 * @param key - Flamework autogenerated key.
	 * @metadata macro
	 */
	public RemoveComponent<T>(entity: Entity, key?: ComponentKey<T>): void;

	public RemoveComponent(entity: Entity, argument1?: unknown, argument2?: unknown): void {
		return remove(this.world, entity, argument1 as never, argument2 as never);
	}

	/**
	 * Retrieves the value of a pair relationship for a specific entity and target.
	 *
	 * @template T - The type of the pair.
	 * @param entity - The entity from which to retrieve the pair relationship.
	 * @param object - The target entity of the relationship (object of the pair).
	 * @param key - Flamework autogenerated key.
	 * @returns The value associated with the pair relationship.
	 * @metadata macro
	 */
	public GetComponent<T extends Pair<defined>>(
		entity: Entity,
		object: Entity,
		key?: ComponentKey<ExtractPredicate<T>>,
	): ResolveValue<T> | undefined;

	/**
	 * Retrieves the value of a component or pair for a specific entity.
	 *
	 * @template T - The type of the component or pair.
	 * @param entity - The entity from which to retrieve the component or pair.
	 * @param key - Flamework autogenerated key.
	 * @returns The value associated with the component or pair.
	 * @metadata macro
	 */
	public GetComponent<T>(entity: Entity, key?: ResolveKey<T>): ResolveValue<T> | undefined;

	public GetComponent(entity: Entity, argument1?: unknown, argument2?: unknown): unknown {
		return get(this.world, entity, argument1 as never, argument2 as never);
	}

	/**
	 * Checks if a pair relationship exists for a specific entity and target.
	 *
	 * @template T - The type of the pair.
	 * @param entity - The entity to check for the pair relationship.
	 * @param object - The target entity of the relationship (object of the pair).
	 * @param key - Flamework autogenerated key.
	 * @returns True if the pair relationship exists, false otherwise.
	 * @metadata macro
	 */
	public HasComponent<T extends Pair<defined>>(
		entity: Entity,
		object: Entity,
		key?: ComponentKey<ExtractPredicate<T>>,
	): boolean;

	/**
	 * Checks if a component or pair exists for a specific entity.
	 *
	 * @template T - The type of the component or pair.
	 * @param entity - The entity to check for the component or pair.
	 * @param key - Flamework autogenerated key.
	 * @returns True if the component or pair exists, false otherwise.
	 * @metadata macro
	 */
	public HasComponent<T>(entity: Entity, key?: ResolveKey<T>): boolean;

	public HasComponent(entity: Entity, argument1?: unknown, argument2?: unknown): boolean {
		return has(this.world, entity, argument1 as never, argument2 as never);
	}

	/**
	 * Retrieves the target entity of a relationship involving the specified entity
	 * and component.
	 *
	 * @template T - The type of the component.
	 * @param entity - The entity to get the target for.
	 * @param key - Flamework autogenerated key.
	 * @returns The target entity if a relationship exists, or undefined otherwise.
	 * @metadata macro
	 */
	public TargetComponent<T>(entity: Entity, key?: ComponentKey<T>): Entity | undefined {
		return target(this.world, entity, key);
	}

	/**
	 * Retrieves the parent entity (target of the ChildOf relationship) for the
	 * given entity.
	 *
	 * @param entity - The entity for which to get the parent.
	 * @returns The parent entity, or undefined if no parent exists.
	 */
	public ParentComponent(entity: Entity): Entity | undefined {
		return target<ChildOf>(this.world, entity);
	}

	public GetAllClassComponents() {
		return (
			Reflect.getOwnMetadata<Constructor[]>(BaseSystem as object, "ECSFramework:Components") ??
			([] as Constructor[])
		);
	}

	public GetComponentKeyByName(name: string) {
		return this.framework.GetComponentKeyByName(name);
	}

	/** @metadata macro */
	public GetClassComponent<T>(key?: ComponentKey<T>) {
		const ctor = this.framework.ComponentsMap.get(key!);
		if (!ctor) {
			throw `Component ${key} does not exist.`;
		}

		return ctor;
	}

	private isTagComponent(ctor: Constructor) {
		return this.framework.IsClassComponentTag(ctor);
	}

	/**
	 * Retrieves the ID of a component or a pair relationship.
	 *
	 * @template T - The type of the component.
	 * @param key - Flamework autogenerated key or pair key.
	 * @returns The component or pair ID.
	 * @metadata macro.
	 */
	public GetComponentId<T>(key?: ResolveKey<T>): Id<ResolveValue<T>> {
		return getId(this.world, key);
	}

	public ClearAllComponents(entity: jecs.Entity) {
		this.world.clear(entity);
	}

	/**
	 * Returns a signal that fires when a component is added to an entity.
	 *
	 * @template T - The type of the component.
	 * @param key - Flamework autogenerated key for the component.
	 * @returns A signal that fires when the component is added to any entity.
	 * @metadata macro
	 */
	public Added<T>(key?: ComponentKey<T>): Signal<[entity: Entity<T>, data: T]> {
		return added(this.world, key);
	}

	/**
	 * Returns a signal that fires when a component is removed from an entity.
	 *
	 * @template T - The type of the component.
	 * @param key - Flamework autogenerated key for the component.
	 * @returns A signal that fires when the component is removed from any entity.
	 * @metadata macro
	 */
	public Removed<T>(key?: ComponentKey<T>): Signal<[entity: Entity<T>]> {
		return removed(this.world, key);
	}

	/**
	 * Returns a signal that fires when a component's value changes on an entity.
	 *
	 * @template T - The type of the component.
	 * @param key - Flamework autogenerated key for the component.
	 * @returns A signal that fires when the component's value changes on any
	 *   entity.
	 * @metadata macro
	 */
	public Changed<T>(key?: ComponentKey<T>): Signal<[entity: Entity<T>, data: T]> {
		return changed(this.world, key);
	}

	public GetComponentKey<T>(runtimeId: Entity) {
		return getKey<T>(runtimeId);
	}

	private createComponentData<T>(ctor: { constructor: (data: unknown) => T }, addtitionalData?: Partial<T>) {
		const finalData = {};
		ctor.constructor(finalData);
		if (addtitionalData !== undefined) {
			for (const [key, _] of pairs(addtitionalData)) {
				finalData[key as never] = addtitionalData[key as never] as never;
			}
		}

		return finalData;
	}
	//#endregion

	//#region Entity
	/**
	 * Creates a new empty entity.
	 *
	 * @returns The created entity.
	 * @metadata macro
	 */
	public SpawnEntity(): jecs.Tag;

	/**
	 * Creates a new entity with the specified tag components.
	 *
	 * @template T - The type of the components.
	 * @param keys - Flamework autogenerated keys.
	 * @returns The created entity.
	 * @metadata macro
	 */
	public SpawnEntity<T extends Array<Tag>>(keys?: ResolveKeys<T>): jecs.Tag;

	/**
	 * Creates a new entity with the specified components and their values.
	 *
	 * @template T - The type of the components.
	 * @param values - The values to set for the components.
	 * @param keys - Flamework autogenerated keys.
	 * @returns The created entity.
	 * @metadata macro
	 */
	public SpawnEntity<T extends Array<unknown>>(
		values: TrailingUndefined<Partial<ResolveValues<T>>>,
		keys?: ResolveKeys<T>,
	): jecs.Tag;

	public SpawnEntity(argument1?: unknown, argument2?: unknown): jecs.Tag {
		const entity = this.world.entity();
		if (argument1 === undefined && argument2 === undefined) return entity;

		this.InsertComponents(entity, argument1 as never, argument2 as never);
		return entity;
	}

	public ExistEntity(entity: jecs.Entity) {
		return this.world.exists(entity);
	}

	public DespawnEntity(entity: jecs.Entity) {
		this.AddComponent<DestroyComponent>(entity);
		this.world.delete(entity);
	}
	//#endregion

	//#region Query
	/** @metadata macro */
	public Query<T extends Array<unknown> = []>(
		terms?: ToIds<Calculate<T>["query"]>,
		filterWithout?: ToIds<Calculate<T>["without"]>,
		filterWith?: ToIds<Calculate<T>["with"]>,
	): QueryHandle<ExtractQueryTypes<T>> {
		return query(this.world, terms, filterWithout, filterWith);
	}

	/** @metadata macro */
	public QueryChange<T>(componentTypeId?: ComponentKey<T>, key?: Modding.Caller<"uuid">) {
		return QueryChange<T>(componentTypeId!, key!);
	}

	/** @metadata macro */
	public Each<T>(key?: ResolveKey<T>) {
		return this.world.each(getId(this.world, key));
	}
	//#endregion

	//#region Lifecycle
	public OnStartup() {}
	public OnUpdate() {}
	public OnEffect() {}
	//#endregion
}
